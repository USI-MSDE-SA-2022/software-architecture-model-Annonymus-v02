<html>

<head>
    <title>Software Architecture Model of Tag4You by Marco Tereh</title>
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Fira+Sans|Fira+Mono">
    <link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.0/build/styles/default.min.css">
    <style>
        body,
        * {
            font-family: "Fira Sans";
            scroll-behavior: smooth;
        }

        body {
            margin: 1em;
        }

        #usi-logo {
            width: 75px;
            height: 75px;
        }

        header {
            display: flex;
            align-content: space-between;
            width: 100%;
            justify-items: center;
        }

        header ul {
            list-style: none;
        }

        header .title {
            flex: 1;
            margin-left: 1em;
        }

        html {
            min-height: 100vh;
        }

        pre,
        code {
            font-family: "Fira Mono"
        }

        pre {
            background: rgb(202, 227, 255);
            padding: 1em;
        }

        td {
            text-align: center
        }

        td:last-child {
            text-align: left;
        }

        th {
            font-weight: normal;
            color: rgb(0, 61, 131);
        }

        thead {
            border-bottom: 2px solid rgb(202, 227, 255);
        }

        table {
            width: 100%
        }

        span.task {
            display: inline-flex;
            border-radius: 50%;
            border: 1px solid white;
            background: #ffbc00;
            width: 2em;
            height: 2em;
            justify-content: center;
            align-items: center;
            font-weight: normal;
            margin-top: 2em;
        }

        section.feedback {
            padding: 2em;
            background-color: rgb(92, 192, 223);
            background-image: linear-gradient(1deg, white, transparent,rgba(255,255,255,0.5) 90%,transparent 100%);
        }

        section.instructions {
            padding: 2em;
            background-color: rgb(255, 241, 196);
            background-image: linear-gradient(1deg, white, transparent,rgba(255,255,255,0.5) 90%,transparent 100%);
        }

        section.instructions::before {
            content: "Task Description";
            font-size: 1.75em;
            color: #ffbc00;
            font-weight: bold;
            transform: translateY(-2em) rotate(1deg);
            display: block;
            margin-bottom: -2em;
            text-align: center;
        }

        section.pass, section.exceed, section.ok {
            margin-top: 1em;
        }

        section.pass span, section.exceed span, section.hint span, section.ok span {
            margin-right: 0.5em;
            padding: 0.5em;
            display: inline-block;
        }

        section.pass {
            border: 2px solid green;
        }

        section.ok {
            border: 2px solid rgb(6, 175, 6);
        }

        section.exceed {
            border: 2px solid rgb(34, 255, 34);
        }

        section.hint {
            border: 2px solid rgb(255, 214, 34);
        }

        section.pass span {
            background-color: green; color: white;
            background-image: linear-gradient(45deg, #000000a6, transparent);
        }

        section.ok span {
            background-color: rgb(6, 175, 6); color: white;
            background-image: linear-gradient(135deg, #000000a6, transparent);
        }

        section.exceed span {
            background-color: rgb(34, 255, 34); 
            background-image: linear-gradient(-45deg, white, transparent);
        }

        section.hint span {
            background-color: rgb(255, 214, 34);
            background-image: linear-gradient(-45deg, white, transparent);
        }

        .deadline {
            text-align: right;
        }

        p.deadline {
            font-size: 2em;
        }

        .deadline b {
            border-bottom: 1px solid black;
        }

        form label {
            display: inline-block;
            margin-right: 1em;
            vertical-align: middle;
        }


form button {
    min-width: 10em;
    min-height: 2em;
    background: #008d4f;
    color: white;
    font-weight: bold;
    font-size: 1.5em;
}

form input[type=text],
form textarea,
form select {
    flex: 3;
    margin: 0.5em;
	font-size: 1.1em;
}	

form p { display: flex; 
	align-items: stretch;
    min-height: 2.5em;
    padding-left: 0.5em; 
flex-direction: column}

    </style>
</head>
<body>

    <header>    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="usi-logo" x="0px" y="0px" width="200" height="200" viewBox="0 0 200 200" style="enable-background:new 0 0 200 200;" xml:space="preserve" class="injected-svg svg">
        <g>
            <path d="M180,41.7h-51.1V31.1h42.2C153.1,12.5,127.8,1,99.9,1C45.2,1.1,0.9,45.4,1,100.1c0,26.8,10.7,51.1,28.1,68.9   c-1.4-2-2.4-4.1-3-6.1c-1-3.5-1-5.9-1.1-15.8v-47.1h14.8v48.5c0,3.4-0.1,6.6,1,9.6c3,7.6,11.3,8.5,16,8.5c2.3,0,8.3-0.1,12.6-3.9   c4.4-3.9,4.4-8.4,4.4-15v-47.7h14.9v49.7c-0.1,8.9-0.1,16.3-8.5,23.5c-8,7-18.4,7.7-23.8,7.7c-4.8,0-9.5-0.6-14-2.1   c-1.8-0.6-3.5-1.4-5-2.3c17.1,14,39,22.4,62.8,22.4c54.7-0.1,99-44.4,98.9-99.1C199,78.1,191.9,58,180,41.7z M175.3,94.4l-6.3-9   c2.1-1.4,8.7-5.7,8.7-17.7c0-2-0.2-4.1-1-6.2c-1.7-4.1-4.6-4.9-6.6-4.9c-3.6,0-4.9,2.5-5.7,4.3c-0.5,1.3-0.6,1.5-1.8,6.6l-1.5,6.9   c-0.9,3.6-1.3,5.4-2,7.2c-1.1,2.6-4.5,9.6-14,9.6c-10.9,0-17.8-9.2-17.8-22.6c0-12.3,6.1-19,11.6-23l6.6,8.8   c-2.8,1.9-8.5,5.7-8.5,14.8c0,5.8,2.6,10.8,7,10.8c4.9,0,5.8-5.3,6.8-10.5l1.3-5.9c1.6-7.7,4.8-18.6,17-18.6   c13.1,0,18.4,12.2,18.4,24.3c0,3.2-0.3,6.7-1.3,10.2C185.1,83.4,182.3,90.1,175.3,94.4z"></path>
        </g>
        </svg>
        <div class="title">
            <h2></h2>
            <h1>Software Architecture Model of Tag4You by Marco Tereh</h1>
        </div>
        <ul>
            <li>Prof. Cesare Pautasso</li>
        </ul>
        </header>

    <main>
        <h1 id="getting-started">Getting started</h1>
<p>You will use <a href="https://www.markdownguide.org/cheat-sheetplan">Markdown</a> and <a href="https://plantuml.com/">PlantUML</a> to describe a software architecture model about your own project.</p>
<p>This document will grow during the semester as you sketch and refine your software architecture model.</p>
<p>When you are done with each task, please push so we can give you feedback about your work.</p>
<p>We begin by selecting a suitable project domain.</p>
<h1 id="ex---domain-selection"><span class='task'>1.</span>  Domain Selection</h1>
<section class="instructions"><p>Submit the name and brief description (about 100 words) of your domain using the following vision statement template:</p>
<pre><code>For [target customers]
Who [need/opportunity/problem]
The [name your project]
Is  [type of project]
That [major features, core benefits, compelling reason to buy]
Unlike [current reality or competitors]
Our Project [summarize main advantages over status quo, unique selling point]
</code></pre>
<p>Please indicate if your choice is:</p>
<ul>
<li>a project you have worked on in the past (by yourself or with a team)</li>
<li>a project you are going to work on this semester in another lecture (which one?)</li>
<li>a new project you plan to build in the future</li>
<li>some existing open source project you are interested to contribute to</li>
</ul>
<p>The chosen domain should be unique for each student.</p>
<p>Please be ready to give a 2 minute presentation about it (you can use a slide but it&#39;s not necessary)</p>
<section class="hint"><span>Hint: </span>to choose a meaningful project look at the rest of the modeling tasks which you are going to perform in the context of your domain.</section></section><p>Project Name: Tag4You</p>
<p>Project Type: Potential future project</p>
<p>Vision Statement:</p>
<p>Companies whose service is to offer a large number of individual items, such as amazon and netflix, require a way for users to find the item(s) they want or need among the many on offer. One way for customers to do so is using tags: products are tagged with specific properties that a user can be interested in. For example: netflix tags some movies as &quot;romantic&quot;. Users interested in romantic movies can search for that and get a list of movies they&#39;re interested in. Unfortunately, these systems are often sorely lacking and provide far too little granularity. For example, Netflix only provides a few dozen tags and there is no way to search for a movie with &quot;female protagonist&quot; or &quot;gay love&quot; or &quot;urban fantasy&quot;. Furthermore, most companies only offer positive search and do not allow customers to <em>exclude</em> items with certain attributes. Tag4you offers a simple and rapid interface to accomplish all of that. Let us imagine a world in which instead of writing &quot;fantasy movie&quot; into netflix&#39;s search bar and being presented with a list of sci-fi TV series, I can write &quot;high fantasy, strong female protagonist, no romance, good music, score &gt; 8, length &lt; 120&quot; and get a movie I actually <em>want</em> to watch instead of the one I have to.</p>
<p>Additional Information:
The advantage of using Tag4You instead of developing the system in-house is clear: not only do you save on development costs and time, the end product is also more stable, feature-rich and provides a uniform query language which users are used to from other companies using our services.</p>
<h1 id="ex---architectural-decision-records"><span class='task'>2.</span>  Architectural Decision Records</h1>
<section class="instructions"><p>Software architecture is about making design decisions that will impact the quality of the software you plan to build.</p>
<p>Let&#39;s practice how to describe an architectural decision. We will keep using ADRs to document architectural decisions in the rest of the model.</p>
<p>Use the following template to capture one or more architectural design decisions in the context of your project domain</p>
<section class="pass"><span>&starf;&star;&star;: </span>1 ADR</section><section class="ok"><span>&starf;&starf;&star;: </span>2 ADR</section><section class="exceed"><span>&starf;&starf;&starf;: </span>&gt;2 ADR</section></section><p><h3>Architectural Decision Record Template</h3><h2 id="adr-0-template">ADR #0 (Template)</h2>
<ol>
<li>What did you decide?</li>
</ol>
<p>Give a short title of solved problem and solution</p>
<ol start="2">
<li>What was the context for your decision?</li>
</ol>
<p>What is the goal you are trying to achieve?</p>
<p>What are the constraints?</p>
<p>What is the scope of your decision? Does it affect the entire architecture?</p>
<ol start="3">
<li>What is the problem you are trying to solve?</li>
</ol>
<p>You may want to articulate the problem in form of a question.</p>
<ol start="4">
<li>Which alternative options did you consider?</li>
</ol>
<p>List at least 3 options</p>
<ol start="5">
<li>Which one did you choose?</li>
</ol>
<p>Pick one of the options as the outcome of your decision</p>
<ol start="6">
<li>What is the main reason for that?</li>
</ol>
<p>List the positive consequences (pros) of your decision:</p>
<ul>
<li>quality improvement</li>
<li>satisfaction of external constraint</li>
</ul>
<p>If any, list the negative consequences (cons)</p>
<ul>
<li>quality degradation</li>
</ul>
</p>
<ol>
<li>What did you decide?</li>
</ol>
<h2 id="programming-language-c">Programming language: C++</h2>
<ol start="2">
<li>What was the context for your decision?</li>
</ol>
<p>A key characteristic for a tagging system is performance. Users expect low-latency answers to their queries. Moreover, the operation is in general rather expensive and many similar systems in the wild impose constraints on their users due to suboptimal performance, such as only allowing a limited number of tags per query. For that reason, the system must be built with performance in mind from the beginning. That starts with the choice of programming language. We choose C++ due to its high runtime performance. This choice will affect the entire development process.</p>
<ol start="3">
<li>What is the problem you are trying to solve?</li>
</ol>
<p>How can we increase run-time performance?</p>
<ol start="4">
<li>Which alternative options did you consider?</li>
</ol>
<p>Java, JavaScript, C++, C, Ruby</p>
<ol start="5">
<li>Which one did you choose?</li>
</ol>
<p>C++</p>
<ol start="6">
<li>What is the main reason for that?</li>
</ol>
<p>Java and JavaScript are both popular languages for building web applications, but they are both significantly less performant than C++. C has similar performance as C++, but less powerful language features and libraries, giving us less flexibility later in the process. Ruby is also in use for web development, but our programmers (i.e. me) do not have much experience with it, leading to a greater chance of bugs and increased development time due to the requirement of learning the language. Performance impact of Ruby is unknown but very unlikely to be greater than C++.</p>
<p>C++ as a language is said to be harder to learn and develop in than other languages, however, our programmers (me) have experience with it already and should not find much trouble using it.</p>
<ol>
<li>What did you decide?</li>
</ol>
<h2 id="api-restful">API: RESTful</h2>
<ol start="2">
<li>What was the context for your decision?</li>
</ol>
<p>Our goal for commercialisation is to give access to this service to other entities, which requires ease of interface. The easier it is to interface with our system, the greater the likelihood that a potential customer will choose to employ our services. A REST API will make it easy for customers to connect to our systems. Most of the process will be unaffected by this decision - the core system still remains the same, only the layer which interfaces with the network is constrained by the type of API to provide.</p>
<ol start="3">
<li>What is the problem you are trying to solve?</li>
</ol>
<p>How can we make it as simple as possible for clients to interface with us?</p>
<ol start="4">
<li>Which alternative options did you consider?</li>
</ol>
<p>REST API, custom protocol, both</p>
<ol start="5">
<li>Which one did you choose?</li>
</ol>
<p>REST API</p>
<ol start="6">
<li>What is the main reason for that?</li>
</ol>
<p>REST APIs are commonplace and as such many programmers know well how to use them and many platforms have components, libraries or frameworks which allow interfacing with such an API easily. Particularly so in the space of web applications, which are always at least in part written in JavaScript, which is capable of interfacing with REST APIs natively. A custom API would allow us more flexibility, but come with a higher learning curve and implementation cost for clients. Some clients might find it easier to send and receive simpler messages instead of having to package everything in HTTP requests, but they are outnumbered.
Implementing both and allowing connections to either would maximise the affordability for our clients, but increase the size and cost of the system, thus we choose against it. However, it is possible to add the second API later on, without significantly increased costs, so we choose to keep the option open and not perform any action that would permanently rule out the possibility of implementing a custom API, so that we may opt to do so if it appears that we still have some resources left after all essential components have been implemented, or as a way to grow after launch if the product is successful enough.</p>
<ol>
<li>What did you decide?</li>
</ol>
<h2 id="commercialisation-software-as-a-service">Commercialisation: software as a service</h2>
<ol start="2">
<li>What was the context for your decision?</li>
</ol>
<p>In creating this system we must consider how to make it profitable, or at least not unprofitable.
Thus it is necessary to consider how we sell it. We choose a software as a service model as that allows us to profit continuously from every client. This requires us to expend additional resources to deploy and maintain the system, but gives us greater control of the platform we are deployed on, decreasing the requirements on portability.</p>
<ol start="3">
<li>What is the problem you are trying to solve?</li>
</ol>
<p>How do we make money from this?</p>
<ol start="4">
<li>Which alternative options did you consider?</li>
</ol>
<p>one-time purchase of software package, software as a service</p>
<ol start="5">
<li>Which one did you choose?</li>
</ol>
<p>software as a service</p>
<ol start="6">
<li>What is the main reason for that?</li>
</ol>
<p>In the software as a service model, every client is a continuous revenue stream, allowing us to profit continuously as long as they keep using our service. It also increases attractivity by decreasing the burden on the clients for deploying the system, though at the cost of an increased expense. We have determined that the pros should outweigh the cons for our clients, as the kind of system which can benefit from a tagging system is one which contains large a volume of content and therefore must already be at a minimum scale, implying high availability of resources for the client and therefore greater affordibility of the cost of our service. The SaaS model also increases affordability for a client who is not sure whether they really need our service in the long term, or has limited initial investment, as it comes with a reduced up-front cost.
This model will require us to maintain our own servers to run the system on, but with an appropriate pricing strategy we can ensure the cost of that is outweighed by the increased profits. Furthermore, full control of the platform on which we deploy reduces the burden of ensuring portability of our system, reducing the amount of work that is necessary before we become profitable.</p>
<p>Deploying our software on a separate server from our clients&#39; machines comes with the cost of increasing latency between queries and responses, but modern network speeds reduce it to an acceptable amount and using dedicated hardware counteracts this effect by avoiding increased processing times due to suboptimal hardware configurations or systems overloaded by other software running on the same machine.</p>
<h1 id="ex---quality-attribute-scenario"><span class='task'>3.</span>  Quality Attribute Scenario</h1>
<section class="instructions"><ol>
<li><p>Pick a scenario for a specific quality attribute. Describe it with natural language.</p>
</li>
<li><p>Refine the scenario using the following structure:</p>
</li>
</ol>
<img src="./puml_e0.svg"><p><em>Stimulus</em>: condition affecting the system</p>
<p><em>Source</em>: entity generating the stimulus</p>
<p><em>Environment</em>: context under which stimulus occurred (e.g., build, test, deployment, startup, normal operation, overload, failure, attack, change)</p>
<p><em>Response</em>: observable result of the stimulus</p>
<p><em>Measure</em>: benchmark or target value defining a successful response</p>
<section class="pass"><span>&starf;&star;&star;: </span>3 scenarios</section><section class="ok"><span>&starf;&starf;&star;: </span>&gt;3 scenarios</section><section class="exceed"><span>&starf;&starf;&starf;: </span>&gt;6 scenarios using challenging qualities</section></section><h2 id="maximum-latency">Maximum Latency</h2>
<p>Quality: <em>Performance (Latency)</em></p>
<p>Scenario: Answers to client requests should be transmitted no more than 100ms after reception of the query</p>
<img src="./puml_e1.svg"><p>Note that precise numbers in this and other scenarios are based on a very basic understanding on my part of the possibilities involved</p>
<h2 id="mutation-visibility">Mutation Visibility</h2>
<p>Quality: <em>Correctness</em></p>
<p>Scenario: Changes to tags may take up to 60 min. for full propagation</p>
<img src="./puml_e2.svg"><p>Responsiveness to write queries is not a high priority and may be sacrificed in exchange for performance of read queries or scalability.</p>
<section class="feedback"><p>This type of Correctness is also known as Read-Write Consistency.</p>
</section><h2 id="influence-on-client-data">Influence on client data</h2>
<p>Quality: <em>Ethics</em></p>
<p>Scenario: Weight of tags and order of result must be based entirely on objective properties of the data (such as creation date) or user-defined criteria. The system may not influence, algorithmically or by admin intervention, the results of a query.</p>
<img src="./puml_e3.svg"><p>&quot;The algorithm&quot; must not influence results beyond the obvious or explicitly requested manner.</p>
<h2 id="intuitiveness-of-query-language">Intuitiveness of query language</h2>
<p>Quality: <em>Usability</em></p>
<p>Scenario: User should succeed in submitting the query they have in mind in less than 3 attempts.</p>
<img src="./puml_e4.svg"><p>The query language must be learnable quickly</p>
<h2 id="failure-mode">Failure Mode</h2>
<p>Quality: <em>Safety</em></p>
<p>Scenario: System should not return incorrect or incomplete results</p>
<img src="./puml_e5.svg"><p>Failures must be transparent - if the user believes an action succeeded, it must truly be so.</p>
<h2 id="attack-recovery">Attack recovery</h2>
<p>Quality: <em>Recoverability</em></p>
<p>Scenario: Following a successful attack it should be possible to restore data to a known good state and resume operation within 1 day</p>
<img src="./puml_e6.svg"><p>Intrusion must be detected and defeated within a day. Furthermore, logs and backups must be kept to allow rapid restoration of the system to a state it was in before the attacker had access to it.</p>
<h2 id="dos-attack-resilience">DoS attack resilience</h2>
<p>Quality: <em>Availability</em></p>
<p>Scenario: System should be able to withstand a targeted denial of service attacks from at least 1000 unique IPs per minute without interrupting operation for regular users</p>
<img src="./puml_e7.svg"><p>Increased response times and aggressive throttling are unavoidable, but users must not be prevented from making queries completely for attacks below a certain scale.
(Actually I have no idea what scale of attack is realistic, 1000IP/m is a very rough guesstimate)</p>
<h2 id="user-logs">User logs</h2>
<p>Quality: <em>Defensibility</em></p>
<p>Scenario: System should keep logs of all users and respective write queries.</p>
<img src="./puml_e8.svg"><p>Activity logs help in detection of and recovery from attacks and credential leaks both for our service as a whole and for our clients&#39; individual databases</p>
<section class="feedback"><ul>
<li>This may also be called Auditability.</li>
<li>The Event Sourcing pattern helps to deliver it.</li>
</ul>
</section><h1 id="ex---quality-attribute-tradeoff"><span class='task'>4.</span>  Quality Attribute Tradeoff</h1>
<section class="instructions"><p>Pick a free combination of two qualities on the <a href="https://usi365.sharepoint.com/:x:/s/MSDE-2022-SoftwareArchitecture/ESVksoXVgMNHtKBKrIwatMYBqorOFaKjxnoqssEy0gNPCg?e=81W7SI">map</a> and write your name to claim it.</p>
<p>Then write a short text giving an example for the tradeoff in this assignment.</p>
<section class="pass"><span>&starf;&star;&star;: </span>1 unique trade-off</section><section class="ok"><span>&starf;&starf;&star;: </span>2 trade-offs</section><section class="exceed"><span>&starf;&starf;&starf;: </span>&gt;2 trade-offs</section></section><h2 id="privacy-vs-defensibility">Privacy vs. Defensibility</h2>
<p>Keeping high-detail logs of everything that goes on on your system and everything that your users do is very useful for detecting and defeating intrusions as well as rolling back any changes that an attacker may have made, but it is a raises huge privacy concerns (also confidentiality but I had to choose one)</p>
<h2 id="defensibility-vs-simplicity">Defensibility vs. Simplicity</h2>
<p>A simple system is easier to attack - complexity makes it more difficult to find and exploit vulnerabilities. That said, this is a tradeoff that is almost always heavily skewed towards simplicity - as we know, security through obscurity is not feasible. Moreover, simplicity has a lot of benefits on its own. Therefore, when we reduce simplicity to increase defensibility, it is always done in a later step, with a simpler system as a base, using code obfuscation and similar techniques.</p>
<h2 id="feasability-vs-usability">Feasability vs. Usability</h2>
<p>(actually affordability vs. accessibility but these two qualities were missing for some reason)</p>
<p>An important aspect of usability is accessibility - systems with low accessibility are extremely unusable for people with impairments. Hence, to increase usability, one must make their systems accessible. However, accessibility is expensive and will significantly increase the time required to develop your product, as well as the cost of doing so.</p>
<p>Note that this tradeoff has already been claimed by somebody else - when I wrote it I wasn&#39;t sure if all the tradeoffs had to be unique. For grading purposes, ignore this one.</p>
<h2 id="usability-and-performance">Usability and Performance</h2>
<p>Usability and performance go hand in hand - a system with bad performance is also unusable
as users become annoyed at waiting times. This effect is especially strong when performance
goes below user reaction speed - i.e. when they are thinking ahead of the program.
When users write or press buttons faster than they are processed, the forced waiting interrupts
their train of thought, worsening not only experience but also function</p>
<h1 id="ex---feature-modeling"><span class='task'>5.</span>  Feature Modeling</h1>
<section class="instructions"><p>In the context of your chosen project domain, describe your domain using a feature model.</p>
<p>The feature model should be correctly visualized using the following template:</p>
<p><img src="./fml_0.svg" alt="Example Feature Model Diagram"></p>
<p>If possible, make use of all modeling constructs.</p>
<section class="pass"><span>&starf;&star;&star;: </span>Include at least 4 non-trivial features</section><section class="ok"><span>&starf;&starf;&star;: </span>Include at least 6 non-trivial features, which are all implemented by your project</section><section class="exceed"><span>&starf;&starf;&starf;: </span>Include more than 8 non-trivial features, indicate which are found in your project and which belong to one competitor</section></section><p><img src="./fml_1.svg" alt="Feature Model Diagram">
The root, Queries, Data modification, Access control, Content Tagging and Result presentation features are not optional and implemented by all competitors.
One competitor, Netflix, has an extremely barebones implementation, with no other features added.
Searching around for a bit I managed to find a competitor with a more interesting system to compare to: vndb.org, a database of visual novels. Their tagging system has the following additional features:</p>
<ul>
<li>Computer-readable format</li>
<li>Weighted tags</li>
<li>Tag aliases</li>
<li>Sub-tags/categories</li>
<li>Tag attributes e.g. spoiler</li>
<li>Tag filter</li>
<li>Sorting</li>
<li>Client-supplied attributes (except of course they are themselves the client)</li>
<li>Paging</li>
<li>Variable page size</li>
</ul>
<h1 id="ex---context-diagram"><span class='task'>6.</span>  Context Diagram</h1>
<section class="instructions"><p>Prepare a context diagram to define the design boundary for your project.</p>
<p>Here is a PlantUML/C4 example to get started.</p>
<p><img src="./puml_0.svg" alt="Example Context Diagram"></p>
<p>Make sure to include all possible user personas and external dependencies you may need.</p>
<section class="pass"><span>&starf;&star;&star;: </span>1 User and 1 Dependency</section><section class="ok"><span>&starf;&starf;&star;: </span>&gt;1 User and &gt;1 Dependency</section><section class="exceed"><span>&starf;&starf;&starf;: </span>&gt;1 User and &gt;1 Dependency, with both incoming and outgoing dependencies</section></section><img src="./puml_e9.svg"><h1 id="ex---component-model-top-down"><span class='task'>7.</span>  Component Model: Top-Down</h1>
<section class="instructions"><p>Within the context of your project domain, represent a model of your modular software architecture decomposed into components.</p>
<p>The number of components in your logical view should be between 6 and 9:</p>
<ul>
<li>At least one component should be further decomposed into sub components</li>
<li>At least one component should already exist. You should plan how to reuse it, by locating it in some software repository and including in your model the exact link to its specification and its price.</li>
<li>At least one component should be stateful.</li>
</ul>
<p>The logical view should represent provide/require dependencies that are consistent with the interactions represented in the process view.</p>
<p>The process view should illustrate how the proposed decomposition is used to satisfy the main use case given by your domain model.</p>
<p>You can add additional process views showing how other use cases can be satisfied by the same set of components.</p>
<p>This assignment will focus on modularity-related decisions, we will worry about deployment and the container view later.</p>
<p>Here is a PlantUML example logical view and process view.</p>
<img src="./puml_e10.svg"><img src="./puml_e11.svg"><section class="hint"><span>Hint: </span>How to connect sub-components to other external components? Use this pattern.</section><img src="./puml_e12.svg"><section class="pass"><span>&starf;&star;&star;: </span>6 components (1 decomposed), 1 use case/process view</section><section class="ok"><span>&starf;&starf;&star;: </span>6 components (1 decomposed), 2 use case/process view</section><section class="exceed"><span>&starf;&starf;&starf;: </span>&gt;6 components (&gt;1 decomposed) and &gt;2 use case/process view</section></section><h2 id="logical-view">Logical View</h2>
<img src="./puml_e13.svg"><h2 id="process-views">Process Views</h2>
<img src="./puml_e14.svg"><img src="./puml_e15.svg"><img src="./puml_e16.svg"><h1 id="ex---component-model-bottom-up"><span class='task'>8.</span>  Component Model: Bottom-Up</h1>
<section class="instructions"><p>Within the context of your project domain, represent a model of your modular software architecture decomposed into components.</p>
<p>To design this model you should attempt to buy and reuse as many components as possible.</p>
<p>In addition to the logical and process views, you should give a precise list to all sources and prices of the components you have selected to be reused.</p>
<p>Write an ADR to document your component selection process (indicating which alternatives were considered).</p>
<section class="pass"><span>&starf;&star;&star;: </span>Existing design with at least 1 reused components (1 Logical View, 1 Process View)</section><section class="ok"><span>&starf;&starf;&star;: </span>Existing design with at least 3 reused components (1 Logical View, 1 Process View, 1 ADR)</section><section class="exceed"><span>&starf;&starf;&starf;: </span>Redesign based on &gt;3 reused components (1 Logical View, &gt;1 Process View, &gt;1 ADR)</section></section><p>Note: if I ever actually do this there&#39;s no way in hell I&#39;ll use all those things,
but for the sake of the assignment, these are components that could in theory be
reused.</p>
<img src="./puml_e17.svg"><img src="./puml_e18.svg"><img src="./puml_e19.svg"><img src="./puml_e20.svg"><ol>
<li>What did you decide?</li>
</ol>
<h2 id="authentication-protocol-oauth-2">Authentication Protocol: OAuth 2</h2>
<ol start="2">
<li>What was the context for your decision?</li>
</ol>
<p>We have a need to authenticate users. The API for this must be secure, but
easy to use and simple to implement. OAuth is an existing protocol designed for
precisely these criteria. It is also the most popular one out there, meaning
the programmers of our clients are likely used to it and will find it easy
to implement the client side or re-use an existing library for that purpose.
The rest of the project is largely independent of this choice, requiring only
minor changes in the Client API component and an appropriate implementation
in the Auth Service component</p>
<ol start="3">
<li>What is the problem you are trying to solve?</li>
</ol>
<p>How can we allow users to authenticate in an easy but secure manner?</p>
<ol start="4">
<li>Which alternative options did you consider?</li>
</ol>
<p>OAuth, Kerberos, own solution</p>
<ol start="5">
<li>Which one did you choose?</li>
</ol>
<p>OAuth 2</p>
<ol start="6">
<li>What is the main reason for that?</li>
</ol>
<p>OAuth is a more popular and widely supported protocol than Kerberos.
Its age and popularity also makes it more robust than a self-designed
protocol is likely to be.</p>
<ol>
<li>What did you decide?</li>
</ol>
<h2 id="parser-lexy">Parser: Lexy</h2>
<ol start="2">
<li>What was the context for your decision?</li>
</ol>
<p>Our users send us queries to retrieve data - as a string.
In order to filter the data for an appropriate response, the string needs to be
parsed into a format usable by the application. Lexy can be used for that.
The impact of this choice is mainly in performance.</p>
<ol start="3">
<li>What is the problem you are trying to solve?</li>
</ol>
<p>How can we turn a query string into an object we can use to process data?</p>
<ol start="4">
<li>Which alternative options did you consider?</li>
</ol>
<p>Lexy, custom parser</p>
<ol start="5">
<li>Which one did you choose?</li>
</ol>
<p>Lexy</p>
<ol start="6">
<li>What is the main reason for that?</li>
</ol>
<p>Lexy is an open-source, freely-available parser which allows specification of
grammars in a convenient C++ DSL.
Using a library instead of building it ourselves saves a lot of work and
provides a guarantee of performance.</p>
<p>Unfortunately, although performance is guaranteed to not be <em>bad</em>, it is also
otherwise out of our control, meaning if we find it to be insufficient later on,
we cannot do anything about it.</p>
<ol>
<li>What did you decide?</li>
</ol>
<h2 id="deployment-provider-aws">Deployment provider: AWS</h2>
<ol start="2">
<li>What was the context for your decision?</li>
</ol>
<p>Given that we decided to run our software ourselves instead of selling it to
clients as a package, we have the need for hardware to run it. A multitenant
architecture means we&#39;d also benefit from a scalable solution and that we can
scale horizontally with little effort.</p>
<ol start="3">
<li>What is the problem you are trying to solve?</li>
</ol>
<p>Where will we run our software?</p>
<ol start="4">
<li>Which alternative options did you consider?</li>
</ol>
<p>AWS, fixed host, self-host</p>
<ol start="5">
<li>Which one did you choose?</li>
</ol>
<p>AWS</p>
<ol start="6">
<li>What is the main reason for that?</li>
</ol>
<p>Renting fixed machines from a provider would allow us to run our software at low
cost, but makes it difficult to scale when we need more capacity to accomodate
new or growing clients.</p>
<p>Self-hosting can be very expensive and would likely provide weaker guarantees
on availability and failure recovery than outsourcing.</p>
<p>AWS is rather expensive as hosting goes due to its flexibility, but allows us to
increase and decrease resources programmatically and quickly in response to
client needs.</p>
<img src="./puml_e21.svg"><h1 id="ex---interfaceapi-specification"><span class='task'>9.</span>  Interface/API Specification</h1>
<section class="instructions"><p>In this iteration, we will detail your previous model to specify the provided interface of all components based on their interactions found in your existing process views.</p>
<ol>
<li><p>choose whether to use the top down or bottom up model. If you specify the interfaces of the bottom up model, your interface descriptions should match what the components you reuse already offer.</p>
</li>
<li><p>decide which interface elements are operations, properties, or events.</p>
</li>
</ol>
<p>Get started with one of these PlantUML templates, or you can come up with your own notation to describe the interfaces, as long as it includes all the necessary details.</p>
<p>The first template describes separately the provided/required interfaces of each component.</p>
<p><img src="./puml_1.svg" alt="Separate Required/Provided Interfaces"></p>
<p>The second template annotates the logical view with the interface descriptions: less redundant, but needs the logical dependencies to be modeled to show which are the required interfaces.</p>
<p><img src="./puml_2.svg" alt="Shared Interfaces"></p>
<section class="pass"><span>&starf;&star;&star;: </span>define interfaces of all outer-level components</section><section class="ok"><span>&starf;&starf;&star;: </span>Define interfaces of all outer-level components. Does your architecture publish a Web API? If not, extend it so that it does.</section><section class="exceed"><span>&starf;&starf;&starf;: </span>Also, document the Web API using the OpenAPI language. You can use the <a href="http://api-ace.inf.usi.ch/openapi-to-tree/">OpenAPI-to-Tree</a> tool to visualize the structure of your OpenAPI description.</section></section><img src="./puml_e22.svg"><p>openapi specification:</p>
<pre><code class="language-yaml">openapi: &quot;3.0.2&quot;
info:
  title: Coeus API
  version: &quot;0.1&quot;
paths:
  /adm/collections:
    post:
      description: add a new collection
      responses:
        &quot;200&quot;:
          description: OK
        &quot;401&quot;:
          description: NOT AUTHORISED
  /adm/collections/{id}:
    put:
      description: edit a collection
      responses:
        &quot;200&quot;:
          description: OK
        &quot;401&quot;:
          description: NOT AUTHORISED
    get:
      description: get a collection
      responses:
        &quot;200&quot;:
          description: OK
        &quot;401&quot;:
          description: NOT AUTHORISED
        &quot;404&quot;:
          description: NOT FOUND
    delete:
      description: delete a  collection
      responses:
        &quot;200&quot;:
          description: OK
        &quot;401&quot;:
          description: NOT AUTHORISED
        &quot;404&quot;:
          description: NOT FOUND
  /adm/users/{name}:
    put:
      description: add a new user or change their credentials
      responses:
        &quot;200&quot;:
          description: OK
        &quot;401&quot;:
          description: NOT AUTHORISED
  /collections/{id}:
    get:
      description: perform a query
      parameters:
        - in: query
          name: q
          schema:
            type: string
          description: the query
      responses:
        &quot;200&quot;:
          description: OK
        &quot;404&quot;:
          description: NOT FOUND
    post:
      description: add a new item
      responses:
        &quot;200&quot;:
          description: OK
        &quot;401&quot;:
          description: NOT AUTHORISED
        &quot;404&quot;:
          description: NOT FOUND
  /collections/{id}/{iid}
    get:
      description: get an item
      responses:
        &quot;200&quot;:
          description: OK
        &quot;401&quot;:
          description: NOT AUTHORISED
        &quot;404&quot;:
          description: NOT FOUND
    delete:
      description: delete an item
      responses:
        &quot;200&quot;:
          description: OK
        &quot;401&quot;:
          description: NOT AUTHORISED
        &quot;404&quot;:
          description: NOT FOUND
  /collections/{id}/{iid}/{tag}:
    put:
      description: add or edit a tag on an item
      responses:
        &quot;200&quot;:
          description: OK
        &quot;401&quot;:
          description: NOT AUTHORISED
        &quot;404&quot;:
          description: NOT FOUND
    delete:
      description: remove a tag from an item
      responses:
        &quot;200&quot;:
          description: OK
        &quot;401&quot;:
          description: NOT AUTHORISED
        &quot;404&quot;:
          description: NOT FOUND
</code></pre>
<p>Two endpoints missing due to bug in the &#39;openapi to tree&#39; app:
<img src="../images/apiTree.png" alt=""></p>
<p>openapi to tree feedback:</p>
<ul>
<li><p>It refuses to render the above document unless you comment the <code>/collections/{id}/{iid}</code> path</p>
</li>
<li><p>The main advantage of a tree structure is that it allows easy representation of
deeply nested structures, but most APIs are very flat and won&#39;t be rendered very well by this.</p>
</li>
<li><p>The tool has tooltips, but they do not include any useful information. There should at least
be the description and non-path parameters</p>
</li>
<li><p>If the tool is meant to be used by people new to openapi, better error messages would be nice</p>
</li>
<li><p>The colors of the get/post/put/delete markers do not provide enough contrast to the
text, they should be less saturated</p>
</li>
<li><p>Occasionally the editor opens an autocomplete tooltip with no content, which it will never close again</p>
<p>This can be reproduced by opening a new instance in an incognito window (i.e. with the default text filled in), deleting the content of one of the autocompleted fields (e.g. &quot;get&quot;) and quickly writing <code>po</code>. The app will open an autocomplete tooltip on <code>p</code>, but if the <code>o</code> comes quickly enough, it will not manage to close it before the options list becomes empty, which seems to freeze it in place</p>
</li>
<li><p>The viewer&#39;s zoom controls are too sensitive for macos scrolling (which is usually much more fine-grained than other platforms&#39;)</p>
</li>
</ul>
<h1 id="ex---connector-view"><span class='task'>10.</span>  Connector View</h1>
<section class="instructions"><p>Extend your existing models introducing the connector view</p>
<p>For every pair of connected components (logical view), pick the most suitable connector. Existing components can play the role of connector, or new connectors may need to be introduced.</p>
<p>Make sure that the interactions shown in the process views reflect the primitives of the selected connector</p>
<section class="pass"><span>&starf;&star;&star;: </span>model existing connectors based on previous model decisions</section><section class="ok"><span>&starf;&starf;&star;: </span>model existing connectors based on previous model decisions, write an ADR about the choice of one connector</section><section class="exceed"><span>&starf;&starf;&starf;: </span>introduce a new type of connector and update your existing process view
(sequence diagram) to show the connector primitives in action</section></section><p><img src="./c5_2.svg" alt=""></p>
<p>Using a new connector QQ (Query Queue) - an N-M connector which allows an arbitrary number of producers and consumers to add tasks to a queue. Producers will create a task and block until it completes. Consumers will pull an available task (which is then marked as &quot;in progress&quot;) and, upon completion, produce a result. The result is returned to the producer that created the task, at which point the task is removed from the queue. Tasks that are marked in progress cannot be consumed by another consumer, but upon triggering a timeout, the status is reset (e.g. if the consumer that was working on it crashed). A consumer that attempts to pull a task while the queue
is empty blocks until one is available.</p>
<ol>
<li>What did you decide?</li>
</ol>
<h2 id="apiquery-processor-connector-query-queue">API/Query Processor connector: Query Queue</h2>
<ol start="2">
<li>What was the context for your decision?</li>
</ol>
<p>The system is required to process a large volume of queries, each of which is
expensive to process, with minimal latency.
Moreover, their availability is critical. If these two components fail, the entire
system is down as they are part of the core service provided.</p>
<p>The outcome of this decision only affects the architecture of the two components involved.</p>
<ol start="3">
<li>What is the problem you are trying to solve?</li>
</ol>
<p>How can we connect API and Query processor so as to tolerate very high loads?</p>
<ol start="4">
<li>Which alternative options did you consider?</li>
</ol>
<p>Procedure call, tuple space, custom connector</p>
<ol start="5">
<li>Which one did you choose?</li>
</ol>
<p>Custom connector.</p>
<ol start="6">
<li>What is the main reason for that?</li>
</ol>
<p>Procedure calls are the most basic connectors, but they are direct 1-1 connectors.
To increase the maximum load we can handle we require the ability to use
multiple query engines and at some point perhaps even multiple client APIs
simultaneously.
Procedure calls do not provide this capability.</p>
<p>Tuple spaces provide n-m connectivity and the ability to block until data
is available, but they are not made for synchronous use. A system can be engineered
to make it work, by having the query processor create a tuple for the response
and making the API attempt to read that immediately after publishing the
request tuple, but it is not the intended use of a tuple space and makes it
difficult to extend the connector with extra features like timeouts.</p>
<p>By creating a custom connector (the query queue) we have made a synchronous,
indirect n-m connector with specialised features fit for our purposes.</p>
<p>The cost of developing it (in manpower, time and money) is added to the project,
but will pay off in the long term as using a specialised connector makes development
of client api and query processor easier and its increased power will enhance
the quality of the final product (e.g. by allowing to scale to larger loads)</p>
<h2 id="process-views-1">Process Views</h2>
<img src="./puml_e23.svg"><img src="./puml_e24.svg"><img src="./puml_e25.svg"><h1 id="ex---adapters-and-coupling"><span class='task'>11.</span>  Adapters and Coupling</h1>
<section class="instructions"><ol>
<li>Highlight the connectors (or components) in your existing bottom-up design playing the role of adapter. (We suggest to use the bottom-up design since when dealing with externally sourced components, their interfaces can be a source of mismatches).</li>
<li>Which kind of mismatch** are they solving?</li>
<li>Introduce a wrapper in your architecture to hide one of the previously highlighted adapters</li>
<li>Where would standard interfaces play a role in your architecture? Which standards could be relevant in your domain?</li>
<li>Explain how one or more pairs of components are coupled according to different coupling facets</li>
<li>Provide more details on how each adapter solves the mismatches identified using pseudo-code or the actual code</li>
<li>How can you improve your architectural model to minimize coupling between components? (Include a revised logical/connector view with your solution)</li>
</ol>
<section class="pass"><span>&starf;&star;&star;: </span>1-5 (with one adapter)</section><section class="ok"><span>&starf;&starf;&star;: </span>1-6 (with at least two adapters)</section><section class="exceed"><span>&starf;&starf;&starf;: </span>1-7 (with at least two adapters)</section><p>** If you do not find any mismatch in your existing design we suggest to introduce one artificially.</p>
<h2 id="hints">Hints</h2>
<ul>
<li><p>(1) Should we find cases where two components cannot communicate (and are doing it wrongly) and highlight they would need an adapter?, or cases where we have already a &quot;component playing the role of adapter in the view&quot; and highlight only the adapter?</p>
<p><em>Both are fine. We assumed that if you draw a dependency (or a connector) the interfaces match, but if you detect that the components that should communicate cannot communicate then of course introduce an adapter to solve the mismatch</em></p>
</li>
<li><p>(2) Please show the details about the two interfaces which do not match (e.g., names of parameters, object structures) so that it becomes clear why an adapter is needed and what the adapter should do to bridge the mismatch</p>
</li>
<li><p>(5-6) These questions are about the implications on coupling based on the decisions you documented in the connector view.
Whenever you have a connector you couple together the components and different connectors will have different forms of coupling</p>
<p>For example, if you use calls everywhere, do you really need them everywhere? is there some pair of components where you could use a message queue instead?</p>
<p>Regarding the coupling facets mentioned in question 5. You do not have to answer all questions related to &quot;discovery&quot;, &quot;session&quot;, &quot;binding&quot;, &quot;interaction&quot;, &quot;timing&quot;, &quot;interface&quot; and &quot;platform&quot; (p.441, Coupling Facets). Just the ones that you think are relevant for your design and by answering them you can get ideas on how to do question 6.</p>
</li>
</ul>
</section><ol>
<li></li>
</ol>
<p>There are no adapters in any of my logical views, not even in the bottom-up view since all the existing components talk to my components, never to each other, so my components can be built to accomodate their interface instead of creating a new one.</p>
<p>So I had to invent some:</p>
<ul>
<li>
Imagine the Client API did not offer a REST API but a proprietary solution which offers the following operations (yes I know that's a terrible API. Maybe that's why the adapter is necessary):

<ul>
<li>setActiveCollection(id)</li>
<li>[result_ids] query(query)</li>
<li>item addItem(id, [tags])</li>
<li>item getItem(id)</li>
<li>removeItem(item)</li>
<li>[tags] getTags(item)</li>
<li>setTags(item, tags)</li>
</ul>
<p>For simplicity we ignore authentication - assume that is either omitted or done before using an undocumented part of the API.
Now a client wants to connect their application which uses the documented REST API with Coeus. An adapter is necessary.</p>
</li>
<li>
The mutation processor is meant to be a bit beefier than that, but we can pretend for the duration of this exercise that it is nothing more than an adapter which translates its operations into sequel queries to run on the database
</li>
</ul>
 2.

<p> The Client API adapter solves a mismatch between the connector <em>type</em> of Client API and the Client as well as a mismatch in the allowed <em>operations</em>: the operations of the REST API cannot be mapped directly to those of the proprietary API.</p>
<p> The Mutation processor also solves a mismatch between connector types, but in its case the operations can be mapped directly (for the purpose of this exercise I&#39;m assuming the schema of the database follows the structure of the application)</p>
<ol start="3">
<li></li>
</ol>
<p> The mutation processor cannot be hidden inside a wrapper as other components do access the database directly, without going through it, but the client API can be wrapped easily:</p>
<img src="./puml_e26.svg"><ol start="4">
<li></li>
</ol>
<p> The SQL database uses a standard interface following the well-known SQL language,
 although caution must be taken since not all databases follow the standard strictly, and most also add non-standard components on top of it.</p>
<p> Further, the REST APIs, though not themselves a standard make use of other standards (JSON, HTTP...)</p>
<ol start="5">
<li></li>
</ol>
<p> I will use the connection made through the query queue from the previous exercise as I think it&#39;ll make for an interesting and somewhat unusual example.</p>
<ul>
<li>Discovery is automatic - the client API simply submits a request without caring who fulfils it. Similarly, the query processor retrieves a request without knowing who it cames from - it is the query queue that decides which instances of the two components are put together.</li>
<li>The query queue is stateful - although every message from the Client API is independent of the previous messages, the messages from the query processor depend both on the previous messages from the CAPI <em>and</em> on the previous messages from the processors.</li>
<li>The binding is early - the components are hardcoded to depend on each other.</li>
<li>Interaction is indirect - CAPI and processor never talk to each other directly, only passing messages through the queue.</li>
<li>Timing, unlike in a regular message queue, is synchronous. The CAPI cannot resume until its request has been fulfilled by an instance of the query processor.</li>
<li>Both components depend on the Query Queue. If its API-side interface changes, so must the client API. Same for the processor&#39;s side. Schema changes most likely involve both sides and require changes in all components. Client API and Query Processor, however, are free to change in any way without affecting the other components as they are not depended on by either the QQ or each other.</li>
<li>The separation by the query queue allows CAPI and processor to be implemented separately and run on different machines. Even, in fact, multiple instances of the same component can run in parallel using different platforms. The query queue itself must, of course remain standardised. I hadn&#39;t thought about the exact method in messages are sent to the QQ when I invented it, but I would envision it as GRPC call or a protobuf message, which means that even if the QQ is deployed on a different platform, the other components are not affected.</li>
</ul>
<ol start="6">
<li></li>
</ol>
<p>Client API - REST adapter:</p>
<pre><code class="language-cpp">id_t[] get_collections(id, query) {
    setActiveCollection(id);
    return query(query);
}
id_t post_collections(id) {
    setActiveCollection(id);
    id_t item_id = createNewItemId();
    addItem(item_id, {});
    return item_id;
}
tuple&lt;item_t, tag_t[]&gt; get_collections(id, iid) {
    item_t item = getItem(iid);
    tag_t[] tags = getTags(item);
    return {item, tags};
}
void delete_collections(id, iid) {
    item_t item = getItem(iid);
    removeItem(item);
}
void put_collections(id, iid, tag) {
    item_t item = getItem(iid);
    tag_t[] tags = getTags(item);
    tags = tags.append(tag);
    setTags(item, tags);
}
void delete_collections(id, iid, tag) {
    item_t item = getItem(iid);
    tag_t[] tags = getTags(item);
    tags = tags.remove(tag);
    setTags(item, tags);
}
</code></pre>
<p>Mutation processor adapter:</p>
<pre><code class="language-sql">addItem(udd)
-&gt;
INSERT INTO items VALUES (udf_new_id(), udd.field1, udd.field2, ...)

removeItem(id)
-&gt;
DELETE FROM items WHERE item_id = id

getItem(id)
-&gt;
SELECT * FROM items, (
    SELECT item_id, GROUP_CONCAT(tag_name + &#39;: &#39; + tag_value) FROM tags WHERE item_id = id
    GROUP BY item_id
) AS tags WHERE item.item_id = id AND item.item_id = tags.item_id

setTag(id, tag, value)
-&gt;
INSERT INTO tags VALUES (id, tag, value)

removeTag(id, tag)
-&gt;
DELETE FROM tags WHERE item_id = id AND tag_name = tag
</code></pre>
<ol start="7">
<li></li>
</ol>
<p>I believe I have already minimised coupling among my components. The query queue does it for the most important two, but the others are also in a minimally-coupled state. No components share state and messages are independent from each other wherever reasonable (obviously not in the database). Binding and discovery among components is static, which I believe is reasonable as any components that are bound together are meant to run on the same machine as single instances. The auth service perhaps could be external, although I believe it still makes sense for that to be an RPC, perhaps using grpc, with a destination address in a configuration file. Anything more loose is a security vulnerability.
Timing is synchronous in most cases with direct interactions, but that is necessitated by the performance constraints. It makes no sense to perform an operation to e.g. add a tag when there&#39;s nobody to execute it yet - the user is expecting feedback <em>now</em>.
The interfaces are all internal so if it is necessary to change one, the other side can be adapted as well (except for the REST APIs, but there&#39;s not really a way around it - if the interface changes the clients will have to as well. Hence why interfaces usually don&#39;t change. The APIs can easily be extended to support new or changed operations without breaking the previous one though).
Finally, the platform is, by necessity, fixed to be the same for all components. This is again a matter of performance. Due to the need for low-latency responses, we decided to implement everything in cpp running on the same machine. In order to accomodate higher throughput, an exception was made for the CAPI and the query processor, but these are still required to be running in very similar environments physically located close together to minimise performance loss.</p>
<h1 id="ex---physical-and-deployment-views"><span class='task'>12.</span>  Physical and Deployment Views</h1>
<section class="instructions"><p>a. Extend your architectural model with the following viewpoints:</p>
<ol>
<li><p>Physical or Container View</p>
</li>
<li><p>Deployment View</p>
</li>
</ol>
<p>Your model should be non-trivial: include more than one physical device/virtual container (or both). Be ready to discuss which connectors are found at the device/container boundaries.</p>
<p>b. Write an ADR about which deployment strategy you plan to adopt. The alternatives to be considered are: big bang, blue/green, shadow, pilot, gradual phase-in, canary, A/B testing.</p>
<p>c. (Optional) Prepare a demo of a basic continuous integration and delivery pipeline for your architectural documentation so that you can obtain a single, integrated PDF with all the viewpoints you have modeled so far.</p>
<p>For example:</p>
<ul>
<li>configure a GitHub webhook to be called whenever you push changes to your documentation</li>
<li>setup a GitHub action (or similar) to build and publish your documentation on a website</li>
</ul>
<section class="pass"><span>&starf;&star;&star;: </span>1 physical view, 1 deployment view, 1 ADR (b.)</section><section class="ok"><span>&starf;&starf;&star;: </span>&gt;1 physical view, &gt;1 deployment view, 1 ADR (b.)</section><section class="exceed"><span>&starf;&starf;&starf;: </span>1 physical view, 1 deployment view, 1 ADR (b.) + 1 demo (c.)</section></section><p>Container view:</p>
<img src="./puml_e27.svg"><p>Deployment view:</p>
<p>I repurposed the C4 notation since I could not find a puml library more
appropriate for deployment views</p>
<img src="./puml_e28.svg"><ol>
<li>What did you decide?</li>
</ol>
<h2 id="deployment-strategy-shadow">Deployment Strategy: Shadow</h2>
<ol start="2">
<li>What was the context for your decision?</li>
</ol>
<p>There are many deployment strategies each with different pros and cons.
Our project is only planned to be deployed on a single instance, but requires
constant availability. This choice will impact the quality of service for our
clients as well as the cost of maintaining the system post-launch.</p>
<ol start="3">
<li>What is the problem you are trying to solve?</li>
</ol>
<p>How can we deploy our system while maximising availability and minimising risk?</p>
<ol start="4">
<li>Which alternative options did you consider?</li>
</ol>
<p>big bang, blue/green, shadow, pilot, gradual phase-in, canary, A/B testing</p>
<ol start="5">
<li>Which one did you choose?</li>
</ol>
<p>Shadow</p>
<ol start="6">
<li>What is the main reason for that?</li>
</ol>
<p>Our system only has a backend - a single instance. That means strategies like
gradual phase-in which split the user base over multiple instances make no sense.
Although the system could be duplicated to allow A/B testing over all components
except the database, the usefulness of doing so is very limited considering the
nature of the project (e.g. no user interface). For similar reasons, canary and
pilot are not a good choice.</p>
<p>Big bang, although low-cost, is high-risk as it makes it impossible to revert
changes which break the system. Blue/green solves that problem, but so does shadow
and it has the additional benefit of allowing us to test the new system without
exposing our users to it, so if something breaks we do not lose availability or
data even temporarily. On the other hand, it is a very expensive option,
requiring us to run multiple copies of the whole system, comparing results of the
deployed system with the shadow system, duplicating the db on every release etc.</p>
<p>For this reason we have decided, depending on resource availability, to
allow use of a more limited shadow system - for example running only one or a few
collections on it or using it only for read operations, eliminating the need to
duplicate the database. This decision will be made on a case-by-case basis on
every release.</p>
<p>Another option that we do not plan to implement immediately but are keeping in
mind for future expansion is a sort of canary deployment:
Although the main system will keep its shadow strategy, developers using our
service will appreciate the availability of a sandbox in which they can
experiment with the API and features of our system without needing to use (and buy)
a collection on the main system. If/when we implement such a sandbox, upon developing
new features we will first deploy them in the sandbox. This will allow us to
observe the system in use and fix any bugs we encounter, as well as gather data
on how the new features are being used, which may inform decisions on how
to tweak the features before they are fully released, at which point they become
immutable as we must retain backwards compatibility on the main system.</p>
<h1 id="ex---availability-and-services"><span class='task'>13.</span>  Availability and Services</h1>
<section class="instructions"><p>The goal of this week is to plan how to deliver your software as a service with high availability.</p>
<ol>
<li>If necessary, change your deployment design so that your software is hosted on a server (which could be running as a Cloud VM). Your SaaS architecture should show how your SaaS can be remotely accessed from a client such as a Web browser, or a mobile app</li>
<li>Sketch your software as a service pricing model (optional)</li>
<li>How would you define the availability requirements in your project domain? For example, what would be your expectation for the duration of planned/unplanned downtimes or the longest response time tolerated by your clients?</li>
<li>Which strategy do you adopt to monitor your service&#39;s availability? Extend your architecture with a watchdog or a heartbeat monitor and motivate your choice with an ADR.</li>
<li>What happens when a stateless component goes down? model a sequence diagram to show what needs to happen to recover one of your critical stateless components</li>
<li>How do you plan to recover stateful components? write an ADR about your choice of replication strategy and whether you prefer consistency vs. availability. Also, consider whether event sourcing would help in your context.</li>
<li>How do you plan to avoid cascading failures? Be ready to discuss how the connectors (modeled in your connector view) impact the reliability of your architecture.</li>
<li>How did you mitigate the impact of your external dependencies being not available? (if applicable)</li>
</ol>
<section class="pass"><span>&starf;&star;&star;: </span>1, 3, 4, one of:  5, 6, 7, 8</section><section class="ok"><span>&starf;&starf;&star;: </span>1, 2, 3, 4, two of:  5, 6, 7, 8</section><section class="exceed"><span>&starf;&starf;&starf;: </span>1, 2, 3, 4, 5, 6, 7, 8</section></section><h1 id="ex---scalability"><span class='task'>14.</span>  Scalability</h1>
<section class="instructions"><p>Now that your architecture delivers your software as a service, let&#39;s redesign it so that it can scale!</p>
<ol>
<li><p>Pick one scalability dimension: number of clients, size of input, size of state, number of dependencies</p>
</li>
<li><p>How well does your architecture scale along the chosen dimension? Where do you expect the bottleneck to be?</p>
</li>
<li><p>Modify your architecture to remove the scalability bottleneck you have identified (show both logical, process and deployment view) - consider whether the API/interface of the bottleneck component should be improved.</p>
</li>
<li><p>Write an ADR regarding the scalability pattern you have introduced.</p>
</li>
<li><p>Write an ADR regarding the issue of component discovery, choosing one of the alternatives: dependency injection vs. directory. Can you identify an existing component playing the role of directory/dependency injection container? Could you give an example of where you would need to add such component to facilitate dynamic component discovery?</p>
</li>
</ol>
<section class="pass"><span>&starf;&star;&star;: </span>1, 2, 3, 5</section><section class="ok"><span>&starf;&starf;&star;: </span>1, 2, 3, 4, 5</section><section class="exceed"><span>&starf;&starf;&starf;: </span>1, 2, 3, 4, 5 then redo 1, 2, 3 for different scalability dimensions</section></section><h1 id="ex---flexibility"><span class='task'>15.</span>  Flexibility</h1>
<section class="instructions"><p>Only dead software stops changing. You just received a message from your customer, they have an idea. Is your architecture ready for it?</p>
<ol>
<li><p>Pick a new use case scenario. Precisely, what exactly do you need to change of your existing architecture so that it can be supported? Model the updated logical/process/deployment views.</p>
</li>
<li><p>Pick another use case scenario so that it can be supported without any major architectural change (i.e., while you cannot add new components, it is possible to extend the interface of existing ones or introduce new dependencies). Illustrate with a process view, how your previous design can satisfy the new requirement.</p>
</li>
<li><p>Change impact. One of your externally sourced component/Web service API has announced it will introduce a breaking change. What is the impact of such change? How can you control and limit the impact of such change? Update your logical view</p>
</li>
<li><p>Open up your architecture so that it can be extended with plugins by its end-users. Where would be a good extension point? Update your logical view and give at least one example of what a plugin would actually do.</p>
</li>
<li><p>Assuming you have a centralized deployment with all stateful components storing their state in the same database, propose a strategy to split the monolith into at least two different microservices. Model the new logical/deployment view as well as the interfaces of each microservice you introduce.</p>
</li>
</ol>
<section class="pass"><span>&starf;&star;&star;: </span>1, one out of 2-5.</section><section class="ok"><span>&starf;&starf;&star;: </span>1, two out of 2-5.</section><section class="exceed"><span>&starf;&starf;&starf;: </span>1-5.</section></section>
    </main>


<footer>

</footer>

</body>

</html>
